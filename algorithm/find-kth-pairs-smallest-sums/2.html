<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function kSmallestPairs(nums1, nums2, k) {
        const heap = new Heap()
        let n1 = nums1.length > k ? k : nums1.length
        let n2 = nums2.length > k ? k : nums2.length
        for (let i = 0; i < n1; i++) {
          for (let j = 0; j < n2; j++) {
            heap.push({ data: [nums1[i], nums2[j]], val: nums1[i] + nums2[j] })
            if (heap.size() > k) {
              heap.pop()
            }
          }
        }

        return heap.data.reduce((a, b) => {
          a.push(b.data)
          return a
        }, [])
      }
      class Heap {
        constructor() {
          this.data = []
          this.compare = (a, b) => b - a
        }

        size() {
          return this.data.length
        }

        swap(n1, n2) {
          const { data } = this
          const temp = data[n1]
          data[n1] = data[n2]
          data[n2] = temp
        }

        push(val) {
          this.data.push(val)
          this.bubblingUp(this.size() - 1)
        }

        pop() {
          if (this.size() === 0) return null
          const { data } = this
          const discard = data[0]
          const newMember = data.pop()
          if (this.size() > 0) {
            data[0] = newMember
            this.bubblingDown(0)
          }

          return discard /* 被踢掉的曾经堆内最小节点 */
        }

        bubblingUp(index) {
          /* 冒泡，把最小的冒到第一个，是按二叉树的父子关系，完全升序 */
          while (index > 0) {
            /* 一层层上去最后会聚焦到 0 */
            /* 下标再减 1 这样就对的上二叉树的父子节点 */
            const parent = (index - 1) >> 1
            const { data } = this
            if (this.compare(data[index].val, data[parent].val) < 0) {
              this.swap(parent, index)
              index = parent
            } else {
              break
            }
          }
        }

        bubblingDown(index) {
          /* 把最大的置换下去，按照二叉树的分布，放到叶子节点的下标，不是完全升序 */
          const { data } = this
          const last = this.size() - 1
          while (true) {
            /* 用二叉树而且不用保证升序的原因是只要第k大，并不关心顺序，二叉树的根节点就是第k大的数 */
            const left = index * 2 + 1
            const right = index * 2 + 2
            let parent = index
            if (left <= last && this.compare(data[left].val, data[parent].val) < 0) {
              parent = left
            }
            /* 在左右子节点中更小的那个，给挤上去 */
            if (right <= last && this.compare(data[right].val, data[parent].val) < 0) {
              parent = right
            }
            if (index !== parent) {
              this.swap(index, parent)
              index = parent
            } else {
              break
            }
          }
        }
      }
    </script>

    <script>
      kSmallestPairs([1, 7, 11], [2, 4, 6], 3)
    </script>
  </body>
</html>
